import numpy
from typing import Callable, ClassVar, overload

class BinningModes:
    __members__: ClassVar[dict] = ...  # read-only
    BinningUnknown: ClassVar[BinningModes] = ...
    __entries: ClassVar[dict] = ...
    x11: ClassVar[BinningModes] = ...
    x22: ClassVar[BinningModes] = ...
    x44: ClassVar[BinningModes] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class CalibrationImageType:
    __members__: ClassVar[dict] = ...  # read-only
    Bright: ClassVar[CalibrationImageType] = ...
    Dark: ClassVar[CalibrationImageType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class DRect:
    bottom: int
    left: int
    right: int
    top: int
    z1: int
    z2: int
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: int, arg1: int, arg2: int, arg3: int) -> None: ...
    @overload
    def __init__(self, arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int) -> None: ...

class DeviceInterface:
    __members__: ClassVar[dict] = ...  # read-only
    CL: ClassVar[DeviceInterface] = ...
    EIO_USB: ClassVar[DeviceInterface] = ...
    PLEORA: ClassVar[DeviceInterface] = ...
    S2I_GIGE: ClassVar[DeviceInterface] = ...
    UNKNOWN: ClassVar[DeviceInterface] = ...
    USB: ClassVar[DeviceInterface] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ExposureModes:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    fps25_mode: ClassVar[ExposureModes] = ...
    fps30_mode: ClassVar[ExposureModes] = ...
    hot_duration_trig_mode: ClassVar[ExposureModes] = ...
    hot_edge_trig_mode: ClassVar[ExposureModes] = ...
    hot_sequence_mode: ClassVar[ExposureModes] = ...
    seq_mode: ClassVar[ExposureModes] = ...
    trig_mode: ClassVar[ExposureModes] = ...
    unknown: ClassVar[ExposureModes] = ...
    xfps_mode: ClassVar[ExposureModes] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ExposureTime:
    def __init__(self, arg0: int, arg1: ExposureTimeUnits) -> None: ...

class ExposureTimeUnits:
    __members__: ClassVar[dict] = ...  # read-only
    Milliseconds: ClassVar[ExposureTimeUnits] = ...
    Seconds: ClassVar[ExposureTimeUnits] = ...
    TenMicroseconds: ClassVar[ExposureTimeUnits] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class FullWellModes:
    __members__: ClassVar[dict] = ...  # read-only
    High: ClassVar[FullWellModes] = ...
    Low: ClassVar[FullWellModes] = ...
    Unknown: ClassVar[FullWellModes] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class LogTraceLevel:
    __members__: ClassVar[dict] = ...  # read-only
    DEBUG: ClassVar[LogTraceLevel] = ...
    ERR: ClassVar[LogTraceLevel] = ...
    FATAL: ClassVar[LogTraceLevel] = ...
    INFO: ClassVar[LogTraceLevel] = ...
    NONE: ClassVar[LogTraceLevel] = ...
    VERBOSE: ClassVar[LogTraceLevel] = ...
    WARNING: ClassVar[LogTraceLevel] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ModelInfo:
    Code: str
    Configuration: str
    DeviceHeight: int
    DeviceWidth: int
    FullCode: str
    Hash: str
    Interface: ModelInterface
    Model: str
    NumSensors: int
    NumTemperatureSensors: int
    PixelSize: int
    Rounder: int
    Set: bool
    TypeName: str
    def __init__(self, *args, **kwargs) -> None: ...

class ModelInterface:
    __members__: ClassVar[dict] = ...  # read-only
    CL: ClassVar[ModelInterface] = ...
    CLB: ClassVar[ModelInterface] = ...
    CLF: ClassVar[ModelInterface] = ...
    CXP: ClassVar[ModelInterface] = ...
    GIGE: ClassVar[ModelInterface] = ...
    S2I_GIGE: ClassVar[ModelInterface] = ...
    USB: ClassVar[ModelInterface] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ROIinfo:
    H: int
    W: int
    X: int
    Y: int
    def __init__(self) -> None: ...

class SLBufferInfo:
    blockID: int
    error: SLError
    frameCount: int
    height: int
    missingPackets: int
    size: int
    timestamp: int
    width: int
    def __init__(self, *args, **kwargs) -> None: ...

class SLDevice:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: SLDeviceInfo) -> None: ...
    @overload
    def __init__(self, arg0: SLDevice) -> None: ...
    @overload
    def __init__(self, transport: DeviceInterface, unit: int = ..., params: str = ..., forceIP: str = ..., logFilePath: str = ...) -> None: ...
    @overload
    def AcquireImage(self, buffer: Buffer, timeout: int = ...) -> SLBufferInfo: ...
    @overload
    def AcquireImage(self, image: SLImage, frame: int = ..., timeout: int = ...) -> SLBufferInfo: ...
    @overload
    def CalibrateTemperatureSensor(self, refTemp1: int, measuredTemp1: int, refTemp2: int, measuredTemp2: int) -> SLError: ...
    @overload
    def CalibrateTemperatureSensor(self, refTemp1: int, measuredTemp1: int, refTemp2: int, measuredTemp2: int, sensorNum: int) -> SLError: ...
    def ClearFrameGrabberMemory(self, numberOfBuffers: int) -> SLError: ...
    def CloseCamera(self) -> SLError: ...
    def EnableFirmwareAveraging(self, arg0: bool) -> None: ...
    def ForceAutoTrigger(self) -> SLError: ...
    def GetBinningMode(self) -> BinningModes: ...
    def GetDeviceInfo(self) -> SLDeviceInfo: ...
    def GetExposureMode(self) -> tuple: ...
    def GetFanControl(self) -> tuple: ...
    def GetFirmwareVersion(self) -> str: ...
    def GetFrameCount(self) -> tuple: ...
    def GetImageXDim(self) -> int: ...
    def GetImageYDim(self) -> int: ...
    @overload
    def GetLatestFrame(self, buffer: Buffer, timeout: int = ...) -> SLBufferInfo: ...
    @overload
    def GetLatestFrame(self, image: SLImage, frame: int = ..., timeout: int = ...) -> SLBufferInfo: ...
    def GetModelInfo(self) -> ModelInfo: ...
    def GetROI(self, outRoi: ROIinfo) -> SLError: ...
    def GoLive(self) -> SLError: ...
    @overload
    def GoLiveWithAutoTrigger(self, expTime_ms: int, numFrames: int, thresholdADU: int, fwAveraging: bool) -> SLError: ...
    @overload
    def GoLiveWithAutoTrigger(self, expTime: ExposureTime, numFrames: int, thresholdADU: int, fwAveraging: bool) -> SLError: ...
    def GoUnLive(self) -> SLError: ...
    def IsConnected(self) -> bool: ...
    def MeasureTemperature(self, sensorNum: int = ...) -> tuple: ...
    def OpenCamera(self, bufferDepth: int = ...) -> SLError: ...
    def ReadBuffer(self, userBuf: SLImage, bufnum: int, timeout: int = ...) -> SLError: ...
    def ReadFrame(self, targetBuffer: SLImage, bufNum: int = ..., radOldestFirst: bool = ...) -> bool: ...
    def RegisterRead(self, addr: int, sensorNum: int = ...) -> int: ...
    def RegisterWrite(self, addr: int, val: int, sensorNum: int = ...) -> SLError: ...
    @staticmethod
    def ScanCameras() -> list[SLDeviceInfo]: ...
    def Set1point5Binning(self, setBinningOn: bool) -> SLError: ...
    def SetBinningMode(self, bMode: BinningModes) -> SLError: ...
    def SetConfigPath(self, configPath: str) -> None: ...
    def SetDDS(self, ddsOn: bool) -> SLError: ...
    def SetExposureMode(self, exMode: ExposureModes) -> SLError: ...
    @overload
    def SetExposureTime(self, expTime_ms: int) -> SLError: ...
    @overload
    def SetExposureTime(self, expTime: ExposureTime) -> SLError: ...
    def SetFanControl(self, on: bool) -> SLError: ...
    def SetFullWell(self, fullWell: FullWellModes) -> SLError: ...
    def SetLogTraceLevel(self, SdkLogTrace: LogTraceLevel, InternalLogTrace: LogTraceLevel) -> None: ...
    def SetNumberOfFrames(self, numFrames: int) -> SLError: ...
    def SetPersistentIP(self, arg0: str, arg1: str, arg2: bool) -> SLError: ...
    def SetROI(self, roi: ROIinfo) -> SLError: ...
    def SetSkipFrames(self, numSkips: int) -> SLError: ...
    def SetSyncDirection(self, out: bool) -> SLError: ...
    def SetSyncInDebounceTime(self, debounceTime10Us: int) -> SLError: ...
    def SetTestMode(self, testImg: bool) -> SLError: ...
    def SoftwareTrigger(self) -> SLError: ...
    @overload
    def StartStream(self) -> SLError: ...
    @overload
    def StartStream(self, callback: Callable, **kwargs) -> SLError: ...
    @overload
    def StartStream(self, expTime_ms: int) -> SLError: ...
    @overload
    def StartStream(self, expTime: ExposureTime) -> SLError: ...
    def StopStream(self) -> SLError: ...

class SLDeviceInfo:
    DetectorIPAddress: str
    ID: str
    Interface: DeviceInterface
    forceIP: str
    logFilePath: str
    params: str
    unit: int
    def __init__(self, *args, **kwargs) -> None: ...

class SLError:
    __members__: ClassVar[dict] = ...  # read-only
    SL_ERROR_ABROTED: ClassVar[SLError] = ...
    SL_ERROR_ACCESS: ClassVar[SLError] = ...
    SL_ERROR_ALREADY_EXISTS: ClassVar[SLError] = ...
    SL_ERROR_BUSY: ClassVar[SLError] = ...
    SL_ERROR_CONFIG_FAILED: ClassVar[SLError] = ...
    SL_ERROR_CONFIG_FILE_NOT_FOUND: ClassVar[SLError] = ...
    SL_ERROR_CORRECTION: ClassVar[SLError] = ...
    SL_ERROR_CRITICAL: ClassVar[SLError] = ...
    SL_ERROR_DEVICE_CLOSED: ClassVar[SLError] = ...
    SL_ERROR_DEVICE_STREAMING: ClassVar[SLError] = ...
    SL_ERROR_INTERNAL: ClassVar[SLError] = ...
    SL_ERROR_INTERRUPTED: ClassVar[SLError] = ...
    SL_ERROR_INVALID_PARAM: ClassVar[SLError] = ...
    SL_ERROR_IO: ClassVar[SLError] = ...
    SL_ERROR_MISSING_PACKETS: ClassVar[SLError] = ...
    SL_ERROR_NOT_ENOUGH_MEMORY: ClassVar[SLError] = ...
    SL_ERROR_NOT_FILLED: ClassVar[SLError] = ...
    SL_ERROR_NOT_FOUND: ClassVar[SLError] = ...
    SL_ERROR_NOT_INIT: ClassVar[SLError] = ...
    SL_ERROR_NOT_SUPPORTED: ClassVar[SLError] = ...
    SL_ERROR_NO_DEVICE: ClassVar[SLError] = ...
    SL_ERROR_OTHER: ClassVar[SLError] = ...
    SL_ERROR_OVERFLOW: ClassVar[SLError] = ...
    SL_ERROR_PIPE: ClassVar[SLError] = ...
    SL_ERROR_READ_FAILED: ClassVar[SLError] = ...
    SL_ERROR_REQUIRES_ADMIN: ClassVar[SLError] = ...
    SL_ERROR_RESENDS: ClassVar[SLError] = ...
    SL_ERROR_SUCCESS: ClassVar[SLError] = ...
    SL_ERROR_TIMEOUT: ClassVar[SLError] = ...
    SL_ERROR_WRITE_FAILED: ClassVar[SLError] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class SLImage:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, image: SLImage) -> None: ...
    @overload
    def __init__(self, iWidth: int, iHeight: int) -> None: ...
    @overload
    def __init__(self, iWidth: int, iHeight: int, iDepth: int) -> None: ...
    @overload
    def __init__(self, tiffFilename: str) -> None: ...
    @staticmethod
    def Array2Frame(arg0: numpy.ndarray[numpy.uint16]) -> SLImage: ...
    @staticmethod
    def ArrayToTiffFile(image: numpy.ndarray[numpy.uint16], filename: str) -> SLError: ...
    def AverageWithThresholding(self, lowerThreshold: int, upperThreshold: int) -> tuple: ...
    def Build(self, iWidth: int, iHeight: int, iDepth: int) -> SLError: ...
    def DefectCorrection(self, defectMap: SLImage) -> SLError: ...
    def DeleteLastNSlices(self, n: int) -> SLError: ...
    def Frame2Array(self, arg0: int) -> numpy.ndarray[numpy.uint16]: ...
    def GainCorrection(self, fldImage: SLImage, darkOffset: int) -> SLError: ...
    def GenerateDefectMap(self, defectMap: SLImage, fullWellMode: FullWellModes, exposure: CalibrationImageType) -> SLError: ...
    @overload
    def GetAverageImage(self) -> SLImage: ...
    @overload
    def GetAverageImage(self, slices: list[int]) -> SLImage: ...
    def GetDepth(self) -> int: ...
    def GetHeight(self) -> int: ...
    def GetMean(self, pRect: DRect = ...) -> float: ...
    def GetMeanAndStd(self, pRect: DRect = ...) -> tuple: ...
    def GetMeanAndStdExcludingDefects(self, rect: DRect = ...) -> tuple: ...
    def GetMedianImage(self) -> SLImage: ...
    def GetPixelVal(self, iX: int, iY: int, iZ: int = ...) -> int: ...
    def GetSlice(self, frame: int, OutImage: SLImage) -> bool: ...
    def GetSubImage(self, inImage: SLImage, outImage: SLImage, startX: int, startY: int, width: int, height: int) -> SLError: ...
    @overload
    def GetSubStack(self, outImage: SLImage, startSlice: int, endSlice: int) -> SLError: ...
    @overload
    def GetSubStack(self, outImage: SLImage, Slices: list[int]) -> SLError: ...
    def GetWidth(self) -> int: ...
    def IsDarkCorrected(self) -> bool: ...
    def IsDefectCorrected(self) -> bool: ...
    def IsGainCorrected(self) -> bool: ...
    def KernelDefectCorrection(self, defectMap: SLImage) -> SLError: ...
    def MedianFilter(self, output: SLImage, windowSize: int) -> SLError: ...
    def OffsetCorrection(self, darkMap: SLImage, darkOffset: int) -> SLError: ...
    def ReadRawImage(self, filename: str, swapEndianness: bool = ...) -> bool: ...
    @staticmethod
    def ReadTiffImage(filename: str, outImage: SLImage) -> bool: ...
    def ResetData(self) -> None: ...
    def RotateClockwise(self, degrees: int, outImage: SLImage) -> SLError: ...
    def SetAsGainMap(self) -> SLError: ...
    def SetAsKernelDefectMap(self) -> SLError: ...
    def SetPixelVal(self, val: int, iX: int, iY: int, iZ: int = ...) -> SLError: ...
    def Stack2List(self) -> list: ...
    def WriteRawImage(self, filename: str) -> bool: ...
    def WriteTiffImage(self, filename: str, bits: int = ...) -> bool: ...
    def __and__(self, arg0: SLImage) -> SLImage: ...
    def __eq__(self, arg0: SLImage) -> bool: ...
    def __iand__(self, arg0: SLImage) -> SLImage: ...
    def __ior__(self, arg0: SLImage) -> SLImage: ...
    def __or__(self, arg0: SLImage) -> SLImage: ...
